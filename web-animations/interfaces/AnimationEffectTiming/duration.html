<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationEffectTiming.duration</title>
<link rel="help" href="https://drafts.csswg.org/web-animations/#dom-animationeffecttiming-duration">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<script src="../../resources/timing-tests.js"></script>
<body>
<div id="log"></div>
<script>
'use strict';

for (const duration of gGoodDurationValues) {
  test(t => {
    const anim = createDiv(t).animate(null, 2000);
    anim.effect.timing.duration = duration.specified;
    if (typeof duration.specified === 'number') {
      assert_time_equals_literal(anim.effect.timing.duration, duration.specified,
                                'Updates specified duration');
    } else {
      assert_equals(anim.effect.timing.duration, duration.specified,
                    'Updates specified duration');
    }
    assert_time_equals_literal(anim.effect.getComputedTiming().duration,
                               duration.computed,
                               'Updates computed duration');
  }, `Allows setting the duration to ${duration.specified}`);
}

for (const invalid of gBadDurationValues) {
  test(t => {
    assert_throws(new TypeError, () => {
      createDiv(t).animate(null, { duration: invalid });
    });
  }, 'Throws when setting invalid duration: '
     + (typeof invalid === 'string' ? `"${invalid}"` : invalid));
}

test(t => {
  const anim = createDiv(t).animate(null, { duration: 100000, fill: 'both' });
  anim.finish();
  assert_equals(anim.effect.getComputedTiming().progress, 1,
                'progress when animation is finished');
  anim.effect.timing.duration *= 2;
  assert_time_equals_literal(anim.effect.getComputedTiming().progress, 0.5,
                             'progress after doubling the duration');
  anim.effect.timing.duration = 0;
  assert_equals(anim.effect.getComputedTiming().progress, 1,
                'progress after setting duration to zero');
  anim.effect.timing.duration = 'auto';
  assert_equals(anim.effect.getComputedTiming().progress, 1,
                'progress after setting duration to \'auto\'');
}, 'Allows setting the duration of an animation in progress');

promise_test(t => {
  const anim = createDiv(t).animate(null, 100 * MS_PER_SEC);
  return anim.ready.then(() => {
    const originalStartTime   = anim.startTime;
    const originalCurrentTime = anim.currentTime;
    assert_time_equals_literal(
      anim.effect.getComputedTiming().duration,
      100 * MS_PER_SEC,
      'Initial duration should be as set on KeyframeEffect'
    );

    anim.effect.timing.duration = 200 * MS_PER_SEC;
    assert_time_equals_literal(
      anim.effect.getComputedTiming().duration,
      200 * MS_PER_SEC,
      'Effect duration should have been updated'
    );
    assert_times_equal(anim.startTime, originalStartTime,
                       'startTime should be unaffected by changing effect ' +
                       'duration');
    assert_times_equal(anim.currentTime, originalCurrentTime,
                       'currentTime should be unaffected by changing effect ' +
                       'duration');
  });
}, 'Allows setting the duration of an animation in progress such that the' +
   ' the start and current time do not change');

</script>
</body>
